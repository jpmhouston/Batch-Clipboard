//
//  Clipboard.swift
//  Batch Clipboard
//
//  Created by Pierre Houston on 2024-07-10.
//  Portions Copyright © 2025 Bananameter Labs. All rights reserved.
//
//  Based on Clipboard.swift from the Maccy project
//  Portions Copyright © 2024 Alexey Rodionov. All rights reserved.
//

import AppKit
import Sauce

class Clipboard: CustomDebugStringConvertible {
  static let shared = Clipboard()
  
  typealias OnNewCopyHook = (Clip) -> Void
  
  private var onNewCopyHooks: [OnNewCopyHook] = []
  var changeCount: Int
  
  private let pasteboard = NSPasteboard.general
  
  private var timer: Timer?
  
  private let dynamicTypePrefix = "dyn."
  private let microsoftAnythingPrefix = "com.microsoft."
  private let microsoftSourcePrefix = "com.microsoft.ole.source."
  private let supportedTypes: Set<NSPasteboard.PasteboardType> = [
    .fileURL,
    .html,
    .png,
    .rtf,
    .string,
    .tiff
  ]
  private let ignoredTypes: Set<NSPasteboard.PasteboardType> = [
    .autoGenerated,
    .concealed,
    .transient
  ]
  private let modifiedTypes: Set<NSPasteboard.PasteboardType> = [.modified]
  
  private var enabledTypes: Set<NSPasteboard.PasteboardType> { UserDefaults.standard.enabledPasteboardTypes }
  private var disabledTypes: Set<NSPasteboard.PasteboardType> { supportedTypes.subtracting(enabledTypes) }
  
  private var sourceApp: NSRunningApplication? { NSWorkspace.shared.frontmostApplication }
  
  init() {
    #if DEBUG || UNITTEST 
    if Self.fakeryNeeded {
      changeCount = 0 // avoid accessing the global pasteboard 
      fakeryEngaged = true
    }
    #endif
    changeCount = pasteboard.changeCount
  }
  
  func onNewCopy(_ hook: @escaping OnNewCopyHook) {
    onNewCopyHooks.append(hook)
  }
  
  func clearHooks() {
    onNewCopyHooks = []
  }
  
  func start() {
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      changeCount = fakePasteboardChangeCount
      fakePasteboardObservationOn = true
      return
    }
    #endif
    
    // prepare for the next item copied to the clipboard item to be detected
    changeCount = pasteboard.changeCount
    
    // re-check periodically
    timer = Timer.scheduledTimer(
      timeInterval: UserDefaults.standard.clipboardCheckInterval,
      target: self,
      selector: #selector(checkForChangesInPasteboard),
      userInfo: nil,
      repeats: true
    )
  }
  
  func stop() {
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      fakePasteboardObservationOn = false
      return
    }
    #endif
    
    timer?.invalidate()
    timer = nil
  }
  
  func restart() {
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      start()
      return
    }
    #endif
    
    timer?.invalidate()
    start()
  }
  
  // TODO: maybe rename copy to putOnClipboard or something
  
  func copy(_ string: String, excludeFromHistory: Bool = true) {
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      fakePasteboard = .barestr(string)
      fakePasteboardChangeCount += 1
      if excludeFromHistory {
        changeCount = fakePasteboardChangeCount
      } else {
        checkForChangesInPasteboard()
      }
      return
    }
    #endif
    
    pasteboard.clearContents()
    pasteboard.setString(string, forType: .string)
    
    if excludeFromHistory {
      changeCount = pasteboard.changeCount
    } else {
      checkForChangesInPasteboard()
    }
  }
  
  func copy(_ item: Clip?, removeFormatting: Bool = false, excludeFromHistory: Bool = true) {
    guard let item else { return }
    
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      // save clip in fakePasteboard, don't make new clip replicating what code below does when
      // removeFormatting set and adding .fromSelf key to content because that would involve
      // making a new Clip object, affecting the current state of history
      fakePasteboard = .clip(item.getContents())
      fakePasteboardChangeCount += 1
      if excludeFromHistory {
        changeCount = fakePasteboardChangeCount
      } else {
        checkForChangesInPasteboard()
      }
      return
    }
    #endif
    
    pasteboard.clearContents()
    var contents = item.getContents()
    
    if removeFormatting {
      let stringContents = contents.filter({
        NSPasteboard.PasteboardType($0.type) == .string
      })
      
      // If there is no string representation of data,
      // behave like we didn't have to remove formatting.
      if !stringContents.isEmpty {
        contents = stringContents
      }
    }
    
    for content in contents {
      guard content.type != NSPasteboard.PasteboardType.fileURL.rawValue else { continue }
      pasteboard.setData(content.value, forType: NSPasteboard.PasteboardType(content.type))
    }
    
    // Use writeObjects for file URLs so that multiple files that are copied actually work.
    // Only do this for file URLs because it causes an issue with some other data types (like formatted text)
    // where the item is pasted more than once.
    let fileURLItems: [NSPasteboardItem] = contents.compactMap { item in
      guard item.type == NSPasteboard.PasteboardType.fileURL.rawValue else { return nil }
      guard let value = item.value else { return nil }
      let pasteItem = NSPasteboardItem()
      pasteItem.setData(value, forType: NSPasteboard.PasteboardType(item.type))
      return pasteItem
    }
    pasteboard.writeObjects(fileURLItems)
    
    pasteboard.setString("", forType: .fromSelf)
    
    if excludeFromHistory {
      changeCount = pasteboard.changeCount
    } else {
      checkForChangesInPasteboard()
    }
  }
  
  func invokeApplicationCopy(then action: (() -> Void)? = nil) {
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      copy(nextCannedText, excludeFromHistory: false)
      action?()
      return
    }
    #endif
    #if !UNITTEST
    postKeypress(FilterFieldKeyCmd.copyKeyModifiers, FilterFieldKeyCmd.copyKey, then: action)
    #endif
  }
  
  func invokeApplicationPaste(then action: (() -> Void)? = nil) {
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      switch fakePasteboard {
      case .barestr(let str): accumulateStr(str)
      case .clip(let contents): accumulateContents(contents)
      default: break
      }
      action?()
      return
    }
    #endif
    #if !UNITTEST
    postKeypress(FilterFieldKeyCmd.pasteKeyModifiers, FilterFieldKeyCmd.pasteKey, then: action)
    #endif
  }
  
  // Based on https://github.com/Clipy/Clipy/blob/develop/Clipy/Sources/Services/PasteService.swift.
  func postKeypress(_ modifiers: NSEvent.ModifierFlags, _ key: Key, then action: (() -> Void)? = nil) {
    DispatchQueue.main.async {
      // Add flag that left/right modifier key has been pressed.
      // See https://github.com/TermiT/Flycut/pull/18 for details.
      let cmdFlag = CGEventFlags(rawValue: UInt64(modifiers.rawValue) | 0x000008)
      var vCode = Sauce.shared.keyCode(for: key)
      
      // Force QWERTY keycode when keyboard layout switches to
      // QWERTY upon pressing ⌘ key (e.g. "Dvorak - QWERTY ⌘").
      // See https://github.com/p0deje/Maccy/issues/482 for details.
      if KeyboardLayout.current.commandSwitchesToQWERTY && cmdFlag.contains(.maskCommand) {
        vCode = key.QWERTYKeyCode
      }
      
      let source = CGEventSource(stateID: .combinedSessionState)
      // Disable local keyboard events while pasting
      source?.setLocalEventsFilterDuringSuppressionState([.permitLocalMouseEvents, .permitSystemDefinedEvents],
                                                         state: .eventSuppressionStateSuppressionInterval)
      
      let keyVDown = CGEvent(keyboardEventSource: source, virtualKey: vCode, keyDown: true)
      let keyVUp = CGEvent(keyboardEventSource: source, virtualKey: vCode, keyDown: false)
      keyVDown?.flags = cmdFlag
      keyVUp?.flags = cmdFlag
      keyVDown?.post(tap: .cgAnnotatedSessionEventTap)
      keyVUp?.post(tap: .cgAnnotatedSessionEventTap)
      
      // unlike original maccy, we  need an action method when pasting for advancing the queue afterwards
      // dispatch to the main thread again to add delay for the paste to happen (seems to work)
      DispatchQueue.main.async {
        action?()
      }
    }
  }
  
  func clear() {
    guard UserDefaults.standard.clearSystemClipboard else {
      return
    }
    
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      fakePasteboard = nil
      return
    }
    #endif
    
    pasteboard.clearContents()
  }
  
  // MARK: -
  
  @objc
  func checkForChangesInPasteboard() {
    #if DEBUG || UNITTEST
    if fakeryEngaged {
      // all the functionality below duplicated here :(
      // to avoid multiple sets of ifdefs within
      guard fakePasteboardChangeCount != changeCount else { return }
      changeCount = fakePasteboardChangeCount
      if UserDefaults.standard.ignoreEvents {
        if UserDefaults.standard.ignoreOnlyNextEvent {
          UserDefaults.standard.ignoreEvents = false
          UserDefaults.standard.ignoreOnlyNextEvent = false
        }
        return
      }
      guard let pasteboardItem = fakePasteboard else { return }
      // make new Clip with these contents
      let newClipContents: Set<ClipContent>
      switch pasteboardItem {
      case .barestr(let str):
        let textContent = ClipContent(type: NSPasteboard.PasteboardType.string.rawValue,
                                      value: str.data(using: .utf8))
        newClipContents = [textContent]
      case .clip(let contents):
        let types = contents.map { NSPasteboard.PasteboardType($0.type) }
        if shouldIgnore(Set(types)) { return }
        newClipContents = contents
      }
      let clip = Clip(contents: newClipContents, application: "Fake.app")
      onNewCopyHooks.forEach({ $0(clip) })
      return
    }
    #endif
    
    guard pasteboard.changeCount != changeCount else {
      return
    }
    
    changeCount = pasteboard.changeCount
    
    if UserDefaults.standard.ignoreEvents {
      if UserDefaults.standard.ignoreOnlyNextEvent {
        UserDefaults.standard.ignoreEvents = false
        UserDefaults.standard.ignoreOnlyNextEvent = false
      }
      
      return
    }
    
    // Reading types on NSPasteboard gives all the available
    // types - even the ones that are not present on the NSPasteboardItem.
    // See https://github.com/p0deje/Maccy/issues/241.
    if shouldIgnore(Set(pasteboard.types ?? [])) {
      return
    }
    
    if let sourceAppBundle = sourceApp?.bundleIdentifier, shouldIgnore(sourceAppBundle) {
      return
    }
    
    // Make new clip containing what's on the pasteboard now
    let contents = currentContents()
    guard !contents.isEmpty else {
      return
    }
    let newPasteboardItem = Clip(contents: contents, application: sourceApp?.bundleIdentifier)
    
    // Disseminate
    onNewCopyHooks.forEach({ $0(newPasteboardItem) })
  }
  
  func currentContents() -> [ClipContent] {
    // Some applications (BBEdit, Edge) add 2 items to pasteboard when copying
    // so it's better to merge all data into a single record.
    // - https://github.com/p0deje/Maccy/issues/78
    // - https://github.com/p0deje/Maccy/issues/472
    var contents: [ClipContent] = []
    pasteboard.pasteboardItems?.forEach({ item in
      var types = Set(item.types)
      if types.contains(.string) && isEmptyString(item) && !richText(item) {
        return
      }
      
      if shouldIgnore(item) {
        return
      }
      
      types = types
        .subtracting(disabledTypes)
        .filter { !$0.rawValue.starts(with: microsoftSourcePrefix) }
      
      // Maccy removes .dyn types always to fix a MS Word issue or something, but
      // keeping them fixes LibreOffice, so only remove when evidence of any MS app
      if types.contains(where: { $0.rawValue.starts(with: microsoftAnythingPrefix) }) {
        types = types.filter { !$0.rawValue.starts(with: dynamicTypePrefix) }
      }
      
      // Avoid reading Microsoft Word links from bookmarks and cross-references.
      // https://github.com/p0deje/Maccy/issues/613
      // https://github.com/p0deje/Maccy/issues/770
      if types.isSuperset(of: [.microsoftLinkSource, .microsoftObjectLink]) {
        types = types.subtracting([.microsoftLinkSource, .microsoftObjectLink, .pdf])
      }
      
      types.forEach { type in
        contents.append(ClipContent(type: type.rawValue, value: item.data(forType: type)))
      }
    })
    
    return contents
  }
  
  // MARK: -
  
  private func shouldIgnore(_ types: Set<NSPasteboard.PasteboardType>) -> Bool {
    let ignoredTypes = self.ignoredTypes
      .union(UserDefaults.standard.ignoredPasteboardTypes.map({ NSPasteboard.PasteboardType($0) }))
    
    return types.isDisjoint(with: enabledTypes) ||
      !types.isDisjoint(with: ignoredTypes)
  }
  
  private func shouldIgnore(_ sourceAppBundle: String) -> Bool {
    if UserDefaults.standard.ignoreAllAppsExceptListed {
      return !UserDefaults.standard.ignoredApps.contains(sourceAppBundle)
    } else {
      return UserDefaults.standard.ignoredApps.contains(sourceAppBundle)
    }
  }
  
  private func shouldIgnore(_ item: NSPasteboardItem) -> Bool {
    for regexp in UserDefaults.standard.ignoreRegexp {
      if let string = item.string(forType: .string) {
        do {
          let regex = try NSRegularExpression(pattern: regexp)
          if regex.numberOfMatches(in: string, range: NSRange(string.startIndex..., in: string)) > 0 {
            return true
          }
        } catch {
          return false
        }
      }
    }
    return false
  }
  
  private func isEmptyString(_ item: NSPasteboardItem) -> Bool {
    guard let string = item.string(forType: .string) else {
      return true
    }
    
    return string.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty
  }
  
  private func richText(_ item: NSPasteboardItem) -> Bool {
    if let rtf = item.data(forType: .rtf) {
      if let attributedString = NSAttributedString(rtf: rtf, documentAttributes: nil) {
        return !attributedString.string.isEmpty
      }
    }
    
    if let html = item.data(forType: .html) {
      if let attributedString = NSAttributedString(html: html, documentAttributes: nil) {
        return !attributedString.string.isEmpty
      }
    }
    
    return false
  }
  
  // MARK: -
  
  var debugDescription: String {
    debugCurrentItemDescription()
  }
  
  func debugCurrentItemDescription(ofLength length: Int? = nil) -> String {
    // a variation on the code in checkForChangesInPasteboard()
    // that notably doesn't create new ClipContent objects
    var contents: [(NSPasteboard.PasteboardType, Data)] = []
    pasteboard.pasteboardItems?.forEach({ item in
      var types = Set(item.types)
      if types.contains(.string) && isEmptyString(item) && !richText(item) {
        return
      }
      if shouldIgnore(item) {
        return
      }
      types = types
        .subtracting(disabledTypes)
        .filter { !$0.rawValue.starts(with: microsoftSourcePrefix) }
      if types.contains(where: { $0.rawValue.starts(with: microsoftAnythingPrefix) }) {
        types = types.filter { !$0.rawValue.starts(with: dynamicTypePrefix) }
      }
      if types.isSuperset(of: [.microsoftLinkSource, .microsoftObjectLink]) {
        types = types.subtracting([.microsoftLinkSource, .microsoftObjectLink, .pdf])
      }
      contents += types.compactMap { if let d = item.data(forType: $0) { ($0, d) } else { nil } }
    })
    return Clip.debugContentsDescription(for: contents, ofLength: length)
  }
  
  #if DEBUG || UNITTEST
  static var fakeryNeeded = ProcessInfo.processInfo.processName == "xctest" ||
                            CommandLine.arguments.contains("ui-testing")
  var fakeryEngaged = false
  enum FakePasteboardItem {
    case barestr(String)
    case clip(Set<ClipContent>)
  }
  var fakePasteboard: FakePasteboardItem?
  var fakePasteboardObservationOn = false
  var fakePasteboardChangeDelay = UserDefaults.standard.clipboardCheckInterval
  var fakePasteboardChangeCount = 0 {
    didSet {
      if fakePasteboardObservationOn {
        DispatchQueue.global().asyncAfter(deadline: .now() + fakePasteboardChangeDelay,
                                          execute: checkForChangesInPasteboard)
      }
    }
  }
  var currentText: String? {
    switch fakePasteboard {
    case .barestr(let str): str
    case .clip(let c): strForContents(c)
    default: nil
    }
  }
  func strForContents(_ contents: any Collection<ClipContent>) -> String? {
    if let textContent = contents.first(where: { $0.type == NSPasteboard.PasteboardType.string.rawValue }),
       let d = textContent.value { String(data: d, encoding: .utf8) }
    else { nil }
  }
  var lastPastedClip: Clip?
  var accumulatedDescriptions: [String] = []
  var accumulatedTextBuffer = ""
  func accumulateStr(_ str: String) {
    accumulatedDescriptions.append("'\(str)'")
    accumulatedTextBuffer.append(str)
  }
  func accumulateContents(_ contents: any Collection<ClipContent>) {
    accumulatedDescriptions.append(Clip.debugContentsDescription(contents, ofLength: 0))
    if let str = strForContents(contents) {
      accumulatedTextBuffer.append(str)
    }
  }
  func putPastedClipDescriptionOnClipboard() { copy(accumulatedDescriptions.joined(separator: "\n")) }
  func putPastedClipTextOnClipboard() { copy(accumulatedDescriptions.joined(separator: "\n")) }
  let cannedCopyText = [ "abc", "123", "xyz", "!@#" ]
  var cannedCopyCount = 0
  var nextCannedText: String {
    let r = cannedCopyText[cannedCopyCount % cannedCopyText.count]
    cannedCopyCount += 1 
    return r
  }
  #endif
  
}
